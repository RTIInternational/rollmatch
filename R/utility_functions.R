#----------------------------#
# UTILITY / HELPER FUNCTIONS #
#----------------------------#

#' Create a dataframe of comparisons between all treatment and control data.
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param scored_data The dataset given to runModel with the additional of the
#' score values generated by the propensity score model
#' @param tm The time period indicator
#' @param entry Entry quarter for subject
#' @param id ID variable in dataset
#' 
#' @examples
#' \dontrun{ 
#' # As these functions are hidden, we only provided one example.
#' # See add_balance_table function in the utility_functions file.
#' }
#'
#' @return Dataframe comparing all treatment and control data
#' @keywords internal
create_comparison <- function(scored_data, treatm, tm, entry, id){
  comparison_pool <-
    dplyr::inner_join(scored_data[scored_data[[treat]] == 1, ],
                      scored_data[scored_data[[treat]] == 0, ], by = c(tm))
  comparison_pool$difference <-
    abs(comparison_pool$score.x - comparison_pool$score.y)
  comparison_pool <-
    dplyr::select(comparison_pool,
                  dplyr::one_of(tm, paste0(id, ".x"), paste0(id, ".y")),
                  paste0(entry, ".x"), paste0(entry, ".y"), difference)
  names(comparison_pool) <- c("time", "treat_id", "control_id",
                              paste0("treat_", entry),
                              paste0("control_", entry), "difference")
  return(comparison_pool)
}

#' Use a caliper to trim the data to only observations within threshold
#'
#' @param alpha The pre-specified distance within which to allow matching.
#' The caliper width is calculated as the \code{alpha} multiplied by the
#' pooled standard deviation of the propensity scores or the logit of the
#' propensity scores - depending on the value of \code{match_on}.
#' @param data_pool Dataframe of comparison data to be trimmed.
#' @param scored_data Dataframe of results from model in runModel.
#' @param weighted_pooled_stdev Boolean. FALSE for average pooled standard
#' deviation and TRUE for weighted pooled standard deviation.
#' 
#' @examples
#' \dontrun{ 
#' # As these functions are hidden, we only provided one example.
#' # See add_balance_table function in the utility_functions file.
#' }
#'                          
#' @return Dataframe of the trimmed comparisons based on the alpha value
#' @keywords internal
trim_pool <- function(alpha, data_pool, scored_data, treat, 
                      weighted_pooled_stdev = FALSE){
  var <- "."

  if (dim(data_pool)[1] == 0){
    stop("data_pool is empty")
  }
  if (alpha != 0) {
    var_treat <- var(scored_data[(scored_data[[treat]] == 1), "score"])
    var_untreat <- var(scored_data[(scored_data[[treat]] == 0), "score"])

    if (weighted_pooled_stdev == FALSE){
      pooled_stdev <- sqrt( (var_treat + var_untreat) / 2)
    } else {
      pooled_stdev <-
        sqrt(( (nrow(scored_data[(scored_data[[treat]] == 1), ]) - 1) * var_treat +
           (nrow(scored_data[(scored_data[[treat]] == 0), ]) - 1) * var_untreat) /
        (dim(scored_data)[1] - 2))
    }

    width <- alpha * pooled_stdev
    trimmed_data <- dplyr::filter(data_pool, data_pool$difference <= as.numeric(width))
  } else {
    trimmed_data <- data_pool
  }
  trimmed_data <-
    trimmed_data[order(trimmed_data$time,
                      trimmed_data$treat_id, trimmed_data$difference), ]
  return(trimmed_data)
}


#' Algorithm to find best matches from the comparison pool
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param comparison_pool Dataframe containing the pool from which matches
#' should be found
#' @param num_matches Integer. the number of comparison beneficiary matches to
#' attempt to assign to each treatment beneficiary
#' @param replacement Boolean. Assign comparison beneficiaries with replacement
#' (TRUE) or without replacement (FALSE). If \code{replacement} is TRUE, then
#' comparison beneficiaries will be allowed to be used with replacement within
#' a single quarter, but will be allowed to match to different treatment
#' beneficiaries across multiple quarters.
#' 
#' @examples
#' \dontrun{ 
#' # As these functions are hidden, we only provided one example.
#' # See add_balance_table function in the utility_functions file.
#' }
#'
#' @return Dataframe containing top matches
#' @keywords internal
create_matches <- function(trimmed_pool, num_matches = 3, replacement = TRUE){
  # initialize matches as empty
  matches <- trimmed_pool[0, ]
  
  count <- 1
  # Loop
  repeat {
    # first_choice is the first entry in the comparison pool for each treat_id
    first_choice <- trimmed_pool[!duplicated(trimmed_pool$treat_id), ]
    
    if (nrow(first_choice) == 0)
      break
    
    if (replacement == TRUE){
      # Deal with matches that match in more than one quarter
      multi_quarter <- aggregate(time ~ control_id, first_choice,
                                 function(x) length(unique(x)))
      multi_quarter <- multi_quarter[multi_quarter$time > 1, ]
      
      # Initialize empty multicompare data frame
      cnames <- c("time", "treat_id", "control_id", "difference")
      matched_multi_compare <-
        data.frame(matrix(vector(), 0, 4, dimnames = list(c(), cnames)))
      # Todo: How to initialize the empty df for matches/matched_multi_compare
      
      if (nrow(multi_quarter) != 0) {
        
        multi_compare <-
          aggregate(difference ~ time + control_id,
                    first_choice[first_choice$control_id %in%
                                   multi_quarter$control_id, ], FUN = mean)
        
        multi_compare <- multi_compare[order(multi_compare$control_id,
                                             multi_compare$difference), ]
        multi_compare_assigned <-
          multi_compare[!duplicated(multi_compare$control_id), ]
        
        matched_multi_compare <- # Todo - Change to DPLYR
          merge(multi_compare_assigned[, c('time', 'control_id')], first_choice,
                by = c("control_id", "time")) #, "difference"))
      }
      
      # Deal with matches in single quarter - these can be assigned directly
      matched_single_compare <- first_choice[!first_choice$control_id %in%
                                               multi_quarter$control_id, ]
      current_matches <- dplyr::bind_rows(matched_multi_compare,
                                          matched_single_compare)    
    } else {
      first_choice <- first_choice[order(first_choice$difference), ]
      first_choice <- first_choice[!duplicated(first_choice$control_id), ]
      current_matches <- first_choice[order(first_choice$difference), ]
    }
    # Break out of loop if no matches were assigned
    if (nrow(current_matches) == 0)
      break
    
    matches <- dplyr::bind_rows(matches, current_matches)
    
    if (nrow(trimmed_pool) > 0) {
      #filter out assigned treatment/match pairs
      trimmed_pool <- dplyr::setdiff(trimmed_pool, current_matches)
      
      # Keep records where control_id is not in unique(matches$control_id)
      diff_control_id <-
        dplyr::filter(trimmed_pool,
                      !(control_id %in%
                          unique(current_matches$control_id) ))
      
      if (replacement){
        # if replacement TRUE, keep records where control_id is in
        # matches$control_id and time is the same as the matched time
        keep <-
          dplyr::inner_join(
            trimmed_pool,
            unique(current_matches[, c("time", "control_id")]),
            by = c("control_id", "time"))
      }else{
        keep <- NULL
      }
      #combine the rows to keep and re-sort comparison pool
      trimmed_pool <-
        dplyr::arrange(dplyr::bind_rows(diff_control_id, keep),
                       time, treat_id, difference)
      
      # If num_matches matches have been assigned, remove the treatments
      # from the comparison pool
      matches_count <- matches[matches$treat_id %in%
                                 unique(current_matches$treat_id), ] %>%
        dplyr::group_by(treat_id) %>%
        dplyr::summarise(num.assigned = n()) %>%
        dplyr::filter(num.assigned == num_matches)
      trimmed_pool <-
        dplyr::filter(trimmed_pool,
                      !(treat_id %in% matches_count$treat_id ))
      
    } else break  # break out of loop if comparison pool is empty
    count <- count + 1
  }
  return(matches)
}


#' Create additional columns for the matches dataset
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param Matches Dataframe containing the matches from comparison_pool
#' 
#' @examples
#' \dontrun{ 
#' # As these functions are hidden, we only provided one example.
#' # See add_balance_table function in the utility_functions file.
#' }
#'
#' @return Dataframe containing top matches
#' @keywords internal
add_matches_columns <- function(matches){
  # Assign a number to the matches.  1st, 2nd 3rd, ...
  matches$match_rank <- ave(1:nrow(matches), matches$treat_id, FUN = seq_along)
  matches <- matches[order(matches$treat_id, matches$match_rank), ]
  # Calculate number of total matches for a given treat_id
  matches$total_matches <- ave(1:nrow(matches), matches$treat_id, FUN = length)
  # Add treatment_weight
  matches$treatment_weight <- 1
  # Calculate the weight of each control
  matches$control_matches <- ave(1:nrow(matches),
                                 matches$control_id, FUN = length)
  matches$row_weight <- 1 / matches$total_matches

  return(matches)
}


#' Create control weights for matches dataset, and final data output
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param matches Dataframe containing the matches from comparison_pool
#' @param data The original data provided for the function.
#' 
#' @examples
#' \dontrun{ 
#' # As these functions are hidden, we only provided one example.
#' # See add_balance_table function in the utility_functions file.
#' }
#'
#' @return A list containing two Dataframes. Matches - an updated dataset with
#' control weights added, and data_full an updated version of the original data
#' with weights added.
#' @param id The individual id variable.
#' @keywords internal
create_weights <- function(matches, data, id){
  # Assign weights back to panel dataset
  matches_wide <- reshape(matches, v.names = c("control_id", "difference"),
                          idvar = "treat_id", timevar = "match_rank",
                          direction = "wide",
                          drop = c("row_weight", "control_matches"))
  #Shape weights to apply back to panel dataset
  agg_wt <- matches %>%
    dplyr::group_by(control_id) %>%
    dplyr::summarise(total.weight = sum(row_weight))
  names(agg_wt) <- c("control_id", "control_weight")
  # Add weight to matches dataset
  matches <- merge(matches, agg_wt, by = "control_id")
  # Add in the treat_id with a weight of 1
  names(agg_wt) <- c("id_var", "control_weight")
  agg_wt <- rbind(agg_wt,
                  cbind(id_var = unique(matches$treat_id), control_weight = 1))
  matches_wide <- matches_wide[, grepl("treat_id|control_id",
                                       names(matches_wide))]
  names(matches_wide)[1] <- id
  data_full <- dplyr::left_join(data, matches_wide, by = id)
  data_full$weight <-
    with(agg_wt, control_weight[match(data_full[[id]], id_var)])
  output <- list()
  output$matches <- matches
  output$data_full <- data_full
  return(output)
}

#' Combine the results of rollmatch into a tidy list for output
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param scored_data The dataset given to runModel with the additional of the
#' score values generated by the propensity score model
#' @param data_full The original data provided with the additional of
#' control weights
#' @param matches Dataframe containing the matches from comparison_pool
#' @param tm The time period indicator.
#' @param entry The time period in which the participant enrolled in the
#' intervention (in the same units as the tm variable).
#' @param lookback The number of time periods to look back before the
#' time period of enrollment (1-10).
#' 
#' @examples
#' \dontrun{ 
#' formula <- as.formula(treat ~ qtr_pmt + yr_pmt + age + is_male + is_white +
#'                        is_disabled + is_esrd + months_dual + chron_num + lq_ed +
#'                        yr_ed2 + lq_ip + yr_ip2)
#' tm <- "quarter"; entry <- "entry_q"; lookback <- 1
#' load(url(paste0("https://github.com/RTIInternational/rollmatch/raw/master/",
#'                 "tests/testthat/output.rda")))
#' scored_data <- output$scored_data
#' load(url(paste0("https://github.com/RTIInternational/rollmatch/raw/master/",
#'                 "tests/testthat/out_list.rda")))
#' data_full <- out_list$data_full
#' matches <- out_list$matches
#' out <- make_output(scored_data, data_full, matches, tm, entry, lookback)
#' head(out)
#' }
#' 
#' @return \code{output} returns a list containing the following components:
#' \item{scores}{The propensity scores used in matching.}
#' \item{data}{The original dataset with matches, scores, and weights applied.}
#' \item{summary}{A basic summary table.}
#' \item{ids_not_matched}{A vector of unmatched treatment ids}
#' \item{total_not_matched}{The count of unmatched treatment ids}
#' @keywords internal
make_output <- function(scored_data, data_full, matches,
                        treat, tm, entry, lookback){
  
  out <- list()
  out$scores <- scored_data$score
  out$data <- data_full
  # Number of Rows for Output
  treat_set <- data_full[data_full[[treat]] == 1 &
                           (data_full[[tm]] == data_full[[entry]] - lookback), ]
  comp_set <- data_full[data_full[[treat]] == 0 &
                          (data_full[[tm]] %in% unique(treat_set[[tm]])), ]
  
  nn <- matrix(0, ncol = 2, nrow = 3)
  treat_assigned <- length(unique(matches$treat_id))
  control_assigned <- length(unique(matches$control_id))
  nn[1, ] <- c(nrow(comp_set), nrow(treat_set))
  nn[2, ] <- c(control_assigned, treat_assigned)
  nn[3, ] <- c( (nrow(comp_set) - control_assigned),
                (nrow(treat_set) - treat_assigned))
  dimnames(nn) <- list(c("All", "Matched", "Unmatched"),
                       c("Control", "Treated"))
  out$summary <- nn
  
  all_ids <- unique(scored_data$indiv_id[scored_data[[treat]] == 1])
  discarded <- all_ids[ !(all_ids %in% unique(matches$treat_id))]
  out$ids_not_matched <- discarded
  out$total_not_matched <- length(discarded)
  out$matched_data <- matches
  return(out)
}

#' Add the balancing table to the final output
#' As it's an internal helper function to aid in testing, it is not exported for use outside of the package.
#'
#' @param reduced_data Dataframe of reduced treatment and comparison data
#' @param vars A vector of dataframe column names
#' @param tm The time period indicator
#' @param id ID variable in dataset
#' @param combined_output A list of output for the rollmatch package. 
#' See makeOutput
#' @param treat The Treatment variable
#' @param matches Dataframe containing the matches from comparison_pool
#' 
#' @examples
#' \dontrun{ 
#' data(package="rollmatch", "rem_synthdata_small")
#' reduced_data <- reduce_data(data = rem_synthdata_small, treat = "treat",
#'                             tm = "quarter", entry = "entry_q",
#'                             id = "indiv_id", lookback = 1)
#' fm <- as.formula(treat ~ qtr_pmt + yr_pmt + age)
#' vars <- all.vars(fm)
#' scored_data <- score_data(model_type = "logistic", match_on = "logit", fm = fm,
#'                           reduced_data = reduced_data, treat = "treat",
#'                           tm = "quarter", entry = "entry_q", id = "indiv_id")
#' comparison_pool <- create_comparison(scored_data, treat = "treat",
#'                                      tm = "quarter", entry = "entry_q",
#'                                      id = "indiv_id")
#' trimmed_pool <- trim_pool(alpha = .2, data_pool = comparison_pool,
#'                           treat = "treat", scored_data = scored_data)
#' matches <- create_matches(trimmed_pool = trimmed_pool, num_matches = 3,
#'                           replacement = TRUE)
#' matches <- add_matches_columns(matches)
#' first_output <- create_weights(matches = matches, data = rem_synthdata_small,
#'                                id = "indiv_id")
#' combined_output <- make_output(scored_data = scored_data,
#'                                data_full = first_output$data_full,
#'                                matches = first_output$matches,
#'                                treat = "treat", tm = "quarter",
#'                                entry = "entry_q", lookback = 1)
#' # Add balance table to the output
#' output <- add_balance_table(reduced_data = reduced_data, vars = vars,
#'                             tm = "quarter", id = "indiv_id",
#'                             combined_output = combined_output,
#'                             treat = "treat", matches = first_output$matches)
#' }
#' 
#' @return \code{output} returns a list containing the following additional
#' component to the list out:
#' \item{balance}{The balancing table.}
#' @keywords internal
add_balance_table <- function(reduced_data, vars, tm, id, combined_output,
                              treat, matches){
  treat_group <- reduced_data[, vars] %>% dplyr::group_by(treat)

  full_summary <-
    cbind(as.data.frame(t(dplyr::summarise_all(treat_group, mean))),
          as.data.frame(t(dplyr::summarise_all(treat_group, "sd"))))
  names(full_summary) <-
    c("Full Comparison Mean", "Full Treatment Mean",
      "Full Comparison Std Dev", "Full Treatment Std Dev")

  ta <- matches[, c("time", "treat_id")]
  ca <- matches[, c("time", "control_id")]
  names(ta) <- c(tm, id)
  names(ca) <- c(tm, id)

  data_assigned <- merge(reduced_data, unique(rbind(ta, ca)))

  treat_group <- data_assigned[, vars] %>% dplyr::group_by(treat)

  matched_summary <-
    cbind(as.data.frame(t(dplyr::summarise_all(treat_group, mean))),
          as.data.frame(t(dplyr::summarise_all(treat_group, "sd"))))

  names(matched_summary) <-
    c("Matched Comparison Mean", "Matched Treatment Mean",
      "Matched Comparison Std Dev", "Matched Treatment Std Dev")

  combined_output$balance <- cbind(full_summary, matched_summary)

  combined_output$balance <-
    combined_output$balance[-1, c("Full Treatment Mean", "Full Comparison Mean",
                      "Full Treatment Std Dev", "Full Comparison Std Dev",
                      "Matched Treatment Mean", "Matched Comparison Mean",
                      "Matched Treatment Std Dev",
                      "Matched Comparison Std Dev")]

  return(combined_output)
}
